<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
<title>–ò–≥—Ä–∞ –≤ —Å–ª–æ–≤–∞ üéÆ</title>
<style>
:root {
    --cream: #FFF8F0;
    --beige: #F5E6D3;
    --soft-yellow: #FFE4B5;
    --warm-brown: #C19A6B;
    --dark-brown: #8B6F47;
    --accent-gold: #D4AF37;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, var(--warm-brown) 0%, var(--dark-brown) 100%);
    min-height: 100vh; display: flex; justify-content: center; align-items: center; padding: 10px;
}
.game-container {
    background: var(--cream); border-radius: 20px; padding: 20px; box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    max-width: 1000px; width: 100%;
}
h1 { text-align:center; color:var(--dark-brown); margin-bottom:8px; font-size:1.8em; }
.subtitle { text-align:center; color:var(--warm-brown); margin-bottom:20px; font-size:0.85em; }
.board { display:flex; flex-direction:column; gap:6px; margin-bottom:20px; align-items:center; width: 100%; max-width: 100%; overflow-x: auto; padding: 0 5px; }
.row { display:grid; gap:4px; width: fit-content; margin: 0 auto; }
.tile {
    width:26px; height:26px; border:2px solid var(--beige); border-radius:4px; display:flex; align-items:center;
    justify-content:center; font-size:0.95em; font-weight:bold; text-transform:uppercase; transition:all 0.3s ease; background:white;
    color: #111;
}
.tile.filled { border-color:var(--warm-brown); animation: pop 0.1s ease-in-out; }
.tile.correct { background:#6aaa64; border-color:#6aaa64; color:white; animation:flip 0.5s ease; }
.tile.present { background:#c9b458; border-color:#c9b458; color:white; animation:flip 0.5s ease; }
.tile.absent { background:#787c7e; border-color:#787c7e; color:white; animation:flip 0.5s ease; }
@keyframes pop { 0%,100%{transform:scale(1);}50%{transform:scale(1.1);} }
@keyframes flip { 0%{transform:rotateX(0);}50%{transform:rotateX(90deg);}100%{transform:rotateX(0);} }

.keyboard { display:flex; flex-direction:column; gap:6px; max-width:100%; margin:0 auto; }
.keyboard-row { display:flex; gap:4px; justify-content:center; }
.key {
    padding:12px 4px; min-width:26px; background:var(--beige); border:none; border-radius:4px; font-size:0.7em;
    font-weight:bold; text-transform:uppercase; cursor:pointer; transition:all 0.1s ease; color:var(--dark-brown);
    flex: 1; max-width: 40px;
}
.key:hover { background:var(--soft-yellow); }
.key:active { transform:scale(0.95); }
.key.wide { min-width:45px; font-size:0.65em; max-width: 60px; }
.key.correct { background:#6aaa64; color:white; }
.key.present { background:#c9b458; color:white; }
.key.absent { background:#787c7e; color:white; }

.message { text-align:center; padding:12px; margin-bottom:15px; border-radius:10px; font-weight:bold; display:none; font-size:0.9em; }
.message.show { display:block; animation: slideDown 0.3s ease; }
.message.success { background:#6aaa64; color:white; }
.message.info { background:#c9b458; color:white; }
.message.error { background:#787c7e; color:white; }
@keyframes slideDown { from{opacity:0; transform:translateY(-20px);} to{opacity:1; transform:translateY(0);} }

.stats { text-align:center; color:var(--dark-brown); margin-top:15px; font-size:0.85em; }
.reset-btn { display:block; margin:15px auto 0; padding:10px 25px; background:var(--dark-brown); color:var(--cream);
    border:none; border-radius:8px; font-size:0.95em; font-weight:bold; cursor:pointer; transition:all 0.2s ease; }
.reset-btn:hover { background:var(--accent-gold); transform:translateY(-2px); }

.loading-overlay { position: fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background: rgba(0,0,0,0.45); z-index: 9999; visibility: hidden; opacity: 0; transition: opacity .2s, visibility .2s; }
.loading-overlay.show { visibility: visible; opacity: 1; }
.loading-box { background: var(--cream); color: var(--dark-brown); padding: 18px 26px; border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0,0,0,0.4); font-weight: bold; }

/* Desktop styles */
@media (min-width:768px) {
    .game-container { padding: 40px; }
    h1 { font-size:2.5em; margin-bottom:10px; }
    .subtitle { margin-bottom:30px; font-size:0.9em; }
    .board { gap:8px; margin-bottom:30px; padding: 0; }
    .row { gap:8px; }
    .tile { width:60px; height:60px; font-size:1.8em; border-radius:8px; }
    .keyboard { gap:8px; max-width:700px; }
    .keyboard-row { gap:6px; }
    .key { padding:15px 10px; min-width:40px; font-size:0.85em; border-radius:6px; max-width: none; }
    .key.wide { min-width:65px; font-size:0.75em; max-width: none; }
    .message { padding:15px; margin-bottom:20px; font-size:1em; }
    .stats { margin-top:20px; font-size:0.9em; }
    .reset-btn { margin:20px auto 0; padding:12px 30px; font-size:1em; }
}

/* Small phones */
@media (max-width:360px) {
    h1 { font-size:1.5em; }
    .tile { width:22px; height:22px; font-size:0.85em; }
    .row { gap:3px; }
    .key { padding:10px 2px; min-width:22px; font-size:0.65em; }
    .key.wide { min-width:38px; font-size:0.6em; }
}

/* Medium phones */
@media (min-width:361px) and (max-width:420px) {
    .tile { width:28px; height:28px; font-size:1em; }
}

/* Larger phones */
@media (min-width:421px) and (max-width:767px) {
    .tile { width:35px; height:35px; font-size:1.2em; }
    .row { gap:5px; }
}
</style>
</head>
<body>
<div class="game-container">
    <h1>–ò–≥—Ä–∞ –≤ —Å–ª–æ–≤–∞ üéÆ</h1>
    <p class="subtitle">–£–≥–∞–¥–∞–π —Å–ª–æ–≤–æ, —á—Ç–æ–±—ã –ø—Ä–æ–π—Ç–∏ –¥–∞–ª—å—à–µ :)</p>
    <div class="message" id="message"></div>

    <div class="board" id="board"></div>

    <div class="keyboard" id="keyboard"></div>

    <div class="stats">
        –ü–æ–ø—ã—Ç–æ–∫: <span id="attempts">0</span>
    </div>

    <button class="reset-btn" id="resetBtn">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
</div>

<div id="loadingOverlay" class="loading-overlay">
    <div class="loading-box">–ó–∞–≥—Ä—É–∑–∫–∞ —Å–ª–æ–≤–∞—Ä—è‚Ä¶</div>
</div>

<script>
// ---------- CONFIG --------
const TARGET_WORD = '–ü–û–ó–î–†–ê–í–õ–ï–ù–ò–ï';
const WORD_LENGTH = TARGET_WORD.length;
const INITIAL_ROWS = 6;
const DICT_FILES = ['russian.utf-8', 'russian.txt'];

// ---------- STATE ----------
let currentRow = 0;
let currentTile = 0;
let gameOver = false;
let attempts = 0;
let guessedWords = [];
let keyboardState = {};
let VALID_WORDS = new Set();
let dictLoaded = false;
let boardState = [];

const keyboardLayout = [
    ['–ô','–¶','–£','–ö','–ï','–ù','–ì','–®','–©','–ó','–•','–™'],
    ['–§','–´','–í','–ê','–ü','–†','–û','–õ','–î','–ñ','–≠'],
    ['ENTER','–Ø','–ß','–°','–ú','–ò','–¢','–¨','–ë','–Æ','‚å´']
];

const loadingOverlay = document.getElementById('loadingOverlay');
const resetBtn = document.getElementById('resetBtn');

function showLoading(){ loadingOverlay.classList.add('show'); resetBtn.disabled=true; resetBtn.style.opacity="0.6"; }
function hideLoading(){ loadingOverlay.classList.remove('show'); resetBtn.disabled=false; resetBtn.style.opacity=""; }

function showMessage(text,type,permanent=false){
    const message=document.getElementById('message');
    message.textContent=text;
    message.className=`message ${type} show`;
    if(!permanent) setTimeout(()=>message.classList.remove('show'),3000);
}

// ---------- DICTIONARY ----------
async function loadDictionary(){
    showLoading();
    for(const name of DICT_FILES){
        try{
            const r=await fetch(name);
            if(!r.ok) throw new Error('HTTP '+r.status);
            const txt=await r.text();
            VALID_WORDS=new Set(txt.split(/\r?\n/).map(s=>s.trim().toUpperCase()).filter(Boolean));
            dictLoaded=true; hideLoading(); return;
        }catch(e){ console.warn(`Failed to load "${name}"`,e); }
    }
    dictLoaded=false; hideLoading();
    showMessage('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–ª–æ–≤–∞—Ä—å.','error');
}

// ---------- BOARD ----------
function createEmptyRowState(){ return new Array(WORD_LENGTH).fill(''); }
function addRowToBoard(rowIndex){
    const board=document.getElementById('board');
    boardState[rowIndex]=createEmptyRowState();
    const row=document.createElement('div');
    row.className='row';
    row.id=`row-${rowIndex}`;
    row.style.gridTemplateColumns=`repeat(${WORD_LENGTH},1fr)`;
    for(let c=0;c<WORD_LENGTH;c++){
        const tile=document.createElement('div');
        tile.className='tile';
        tile.id=`tile-${rowIndex}-${c}`;
        row.appendChild(tile);
    }
    board.appendChild(row);
}
function createBoard(){
    const board=document.getElementById('board');
    board.innerHTML='';
    boardState=[];
    for(let r=0;r<INITIAL_ROWS;r++) addRowToBoard(r);
}
function ensureRowExists(rowIndex){ if(boardState[rowIndex]===undefined) addRowToBoard(rowIndex); }

// ---------- KEYBOARD ----------
function createKeyboard(){
    const keyboard=document.getElementById('keyboard');
    keyboard.innerHTML='';
    keyboardLayout.forEach(row=>{
        const rowDiv=document.createElement('div');
        rowDiv.className='keyboard-row';
        row.forEach(k=>{
            const btn=document.createElement('button');
            btn.className=k.length>1?'key wide':'key';
            btn.textContent=k;
            btn.addEventListener('click',()=>handleKey(k));
            rowDiv.appendChild(btn);
        });
        keyboard.appendChild(rowDiv);
    });
}
function updateKeyboardVisuals(letter,state){
    const current=keyboardState[letter];
    if(!current||(current==='absent'&&state!=='absent')||(current==='present'&&state==='correct')) keyboardState[letter]=state;
    document.querySelectorAll('.key').forEach(k=>{
        if(k.textContent===letter){
            k.classList.remove('correct','present','absent');
            k.classList.add(keyboardState[letter]);
        }
    });
}

// ---------- INPUT ----------
function handleKeyPress(e){
    if(gameOver)return;
    const key=e.key.toUpperCase();
    if(key==='ENTER')handleKey('ENTER');
    else if(key==='BACKSPACE')handleKey('‚å´');
    else if(/^[–ê-–Ø–Å]$/.test(key))handleKey(key);
}
function handleKey(key){
    if(gameOver)return;
    if(key==='ENTER')submitGuess();
    else if(key==='‚å´')deleteLetter();
    else if(currentTile<WORD_LENGTH)addLetter(key);
}
function addLetter(letter){
    ensureRowExists(currentRow);
    boardState[currentRow][currentTile]=letter;
    const tile=document.getElementById(`tile-${currentRow}-${currentTile}`);
    if(tile){ tile.textContent=letter; tile.classList.add('filled'); }
    currentTile++;
}
function deleteLetter(){
    if(currentTile>0){
        currentTile--;
        boardState[currentRow][currentTile]='';
        const tile=document.getElementById(`tile-${currentRow}-${currentTile}`);
        if(tile){ tile.textContent=''; tile.classList.remove('filled','correct','present','absent'); }
    }
}

// ---------- GUESS ----------
function checkGuessAndReveal(guess){
    const target=TARGET_WORD.split('');
    const g=guess.split('');
    const count={};
    target.forEach(ch=>count[ch]=(count[ch]||0)+1);
    const result=new Array(WORD_LENGTH).fill('absent');
    for(let i=0;i<WORD_LENGTH;i++){ if(g[i]===target[i]){ result[i]='correct'; count[g[i]]--; } }
    for(let i=0;i<WORD_LENGTH;i++){ if(result[i]==='absent'&&count[g[i]]>0){ result[i]='present'; count[g[i]]--; } }
    for(let i=0;i<WORD_LENGTH;i++){
        setTimeout(()=>{
            const tile=document.getElementById(`tile-${currentRow}-${i}`);
            if(!tile)return;
            tile.textContent=g[i];
            tile.classList.add(result[i],'filled');
            updateKeyboardVisuals(g[i],result[i]);
        },i*200);
    }
}

function submitGuess(){
    if(!dictLoaded){ showMessage('–°–ª–æ–≤–∞—Ä—å –µ—â—ë –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è.','error'); return; }
    if(currentTile<WORD_LENGTH){ showMessage('–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±—É–∫–≤!','error'); return; }
    const guess=boardState[currentRow].join('').toUpperCase();
    if(!VALID_WORDS.has(guess)){ showMessage('–¢–∞–∫–æ–≥–æ —Å–ª–æ–≤–∞ –Ω–µ—Ç –≤ —Å–ª–æ–≤–∞—Ä–µ!','error'); return; }
    if(guessedWords.includes(guess)){ showMessage('–¢—ã —É–∂–µ –ø—Ä–æ–±–æ–≤–∞–ª–∞ —ç—Ç–æ —Å–ª–æ–≤–æ!','info'); return; }

    guessedWords.push(guess);
    attempts++; updateAttempts(); saveGameState();
    checkGuessAndReveal(guess);

    if(guess===TARGET_WORD){
        gameOver=true;
        setTimeout(()=>{
            showMessage(`üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è—é, –ª—é–±–∏–º–∞—è, —Ç—ã —É–≥–∞–¥–∞–ª–∞ —Å–ª–æ–≤–æ –∑–∞ ${attempts} –ø–æ–ø—ã—Ç${attempts===1?'–∫—É':attempts<5?'–∫–∏':'–æ–∫'}! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏ –∫–æ–¥, –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏–π —Å–ª–µ–¥—É—é—â—É—é –ª–æ–∫–∞—Ü–∏—é: HAPPYBIRTHDAY18`,'success',true);
            saveGameState();
        },WORD_LENGTH*200+300);
        return;
    }

    setTimeout(()=>{
        currentRow++; currentTile=0; ensureRowExists(currentRow); saveGameState();
    },WORD_LENGTH*200+50);
}

// ---------- UI ----------
function updateAttempts(){ document.getElementById('attempts').textContent=attempts; }

// ---------- SAVE / LOAD ----------
function saveGameState(){
    const state={currentRow,currentTile,gameOver,attempts,guessedWords,keyboardState,boardState};
    localStorage.setItem('wordGameState',JSON.stringify(state));
}
function loadGameState(){
    const data=localStorage.getItem('wordGameState');
    if(!data) return false;
    try{
        const s=JSON.parse(data);
        currentRow = (typeof s.currentRow === 'number') ? s.currentRow : 0;
        currentTile = (typeof s.currentTile === 'number') ? s.currentTile : 0;
        gameOver = !!s.gameOver;
        attempts = (typeof s.attempts === 'number') ? s.attempts : 0;
        guessedWords = Array.isArray(s.guessedWords) ? s.guessedWords : [];
        keyboardState = (s.keyboardState && typeof s.keyboardState === 'object') ? s.keyboardState : {};
        boardState = Array.isArray(s.boardState) ? s.boardState : [];
        return true;
    }catch(e){ console.error('Bad save',e); return false; }
}

function renderLoadedState(){
    const board=document.getElementById('board');
    board.innerHTML='';

    if(!Array.isArray(boardState)) boardState = [];
    while(boardState.length < INITIAL_ROWS) boardState.push(createEmptyRowState());

    for(let r=0;r<boardState.length;r++){
        const row=document.createElement('div');
        row.className='row';
        row.id=`row-${r}`;
        row.style.gridTemplateColumns=`repeat(${WORD_LENGTH},1fr)`;
        for(let c=0;c<WORD_LENGTH;c++){
            const tile=document.createElement('div');
            tile.className='tile';
            tile.id=`tile-${r}-${c}`;
            const ch = boardState[r][c];
            if(ch){
                tile.textContent = ch;
                tile.classList.add('filled');
            }
            row.appendChild(tile);
        }
        board.appendChild(row);
    }

    createKeyboard();

    guessedWords.forEach((g,ri)=>{
        const target=TARGET_WORD.split('');
        const arr=g.split('');
        const count={}; target.forEach(ch=>count[ch]=(count[ch]||0)+1);
        const res=new Array(WORD_LENGTH).fill('absent');
        for(let i=0;i<WORD_LENGTH;i++){ if(arr[i]===target[i]){res[i]='correct'; count[arr[i]]--;}}
        for(let i=0;i<WORD_LENGTH;i++){ if(res[i]==='absent'&&count[arr[i]]>0){res[i]='present'; count[arr[i]]--;}}
        for(let i=0;i<WORD_LENGTH;i++){
            const tile=document.getElementById(`tile-${ri}-${i}`);
            if(tile){
                tile.classList.add(res[i],'filled');
                if(!tile.textContent) tile.textContent = arr[i];
                updateKeyboardVisuals(arr[i],res[i]);
            }
        }
    });

    Object.keys(keyboardState).forEach(letter=>{
        updateKeyboardVisuals(letter, keyboardState[letter]);
    });

    updateAttempts();

    if(gameOver){
        showMessage(`üéâ –ü–æ–∑–¥—Ä–∞–≤–ª—è—é! –¢—ã —É–≥–∞–¥–∞–ª–∞ —Å–ª–æ–≤–æ –∑–∞ ${attempts} –ø–æ–ø—ã—Ç${attempts===1?'–∫—É':attempts<5?'–∫–∏':'–æ–∫'}! –ö–æ–¥, –æ—Ç–∫—Ä—ã–≤–∞—é—â–∏–π —Å–ª–µ–¥—É—é—â—É—é –ª–æ–∫–∞—Ü–∏—é: HAPPYBIRTHDAY18`,'success',true);
    }
}

// ---------- GAME ----------
resetBtn.addEventListener('click',()=>{
    localStorage.removeItem('wordGameState');
    location.reload();
});

async function initGame(){
    await loadDictionary();
    const hasSave=loadGameState();
    if(dictLoaded){
        if(hasSave){ renderLoadedState(); }
        else{ createBoard(); createKeyboard(); }
        document.addEventListener('keydown',handleKeyPress);
        updateAttempts();
    }else showMessage('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä—É.','error');
}

initGame();
</script>
</body>
</html>
